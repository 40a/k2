# -*- mode: ruby -*-
# vi: set ft=ruby :

# DO NOT EDIT THIS FILE.
# Use the settings.yaml to modify cluster settings.

require 'fileutils'
require 'tempfile'
require 'net/http'
require 'open-uri'
require 'ipaddr'
require 'yaml'
require 'mkmf'
require 'fileutils'

VAGRANTFILE_API_VERSION = "2"
Vagrant.require_version ">= 1.7.2"
 
# Make the MakeMakefile logger write file output to null.
# Probably requires ruby >= 2.0.0
module MakeMakefile::Logging
  @logfile = File::NULL
end

# do some checks on required ENV vars
abort 'KRAKEN_CLUSTER must be defined!' unless ENV['KRAKEN_CLUSTER']
abort "#{ENV['KRAKEN_CLUSTER']} - no such cluster" unless File.directory?(File.join(File.expand_path(File.dirname(__FILE__)), ENV['KRAKEN_CLUSTER']))
abort 'VAGRANT_DOTFILE_PATH is not set to the right location.
Make sure to run vagrant commands through kraken.sh' unless ENV['VAGRANT_DOTFILE_PATH'] == File.join(File.expand_path(File.dirname(__FILE__)), ENV['KRAKEN_CLUSTER'])

# all of the externalized settings get loaded here
def cluster_settings
    settings_yaml = File.join(File.expand_path(File.dirname(__FILE__)), ENV['KRAKEN_CLUSTER'], 'settings.yaml')
    abort "#{settings_yaml} is not present. Did you create it?" unless File.exist?(settings_yaml)
    YAML.load_file(settings_yaml)
end

def install_plugins
  # for this cluster
  plugins_yaml = File.join(File.expand_path(File.dirname(__FILE__)), ENV['KRAKEN_CLUSTER'], 'plugins.yaml')
  install_plugins_from_file(plugins_yaml)

  # plugins required for all clusters
  plugins_yaml = File.join(File.expand_path(File.dirname(__FILE__)), 'plugins.yaml')
  install_plugins_from_file(plugins_yaml)  
end

def install_plugins_from_file(plugins_yaml)
  abort "#{plugins_yaml} does not exist" unless File.exist?(plugins_yaml)
  
  required_plugins = YAML.load_file(plugins_yaml)
  required_plugins['plugins'].each do |plugin|
    need_restart = false
    unless Vagrant.has_plugin? plugin['name'], plugin['version']
      system "vagrant plugin install #{plugin['name']} --plugin-version #{plugin['version']}"
      need_restart = true
    end
    exec "vagrant #{ARGV.join(' ')}" if need_restart
  end
end

def base_ip_address
    settings = cluster_settings
    network = settings['cluster']['network'] || '172.16.1.0/24'

    IPAddr.new(network).to_s.chomp("0")
end

def aws_master
  master = cluster_settings['aws']['masterHostName'] || cluster_settings['aws']['masterPublicIp']
  master
end

def kubernetes_release
  settings = cluster_settings
  version = settings['cluster']['kubernetesVersion'] || 'stable'
  release_url = "https://storage.googleapis.com/kubernetes-release/release/stable.txt"
  
  open(release_url).read().gsub('v','').chomp
end

def coreos_channel
  cluster_settings['coreos']['channel'] || 'alpha'
end

def coreos_boxname
  "coreos-#{coreos_channel}"
end

def coreos_url
  "http://#{coreos_channel}.release.core-os.net/amd64-usr/current"
end

def coreos_release
  settings = cluster_settings
  version = settings['coreos']['version'] || 'latest'
  return version unless version == 'latest'
  
  version_url = "#{coreos_url}/version.txt"
  open(version_url).read().scan(/COREOS_VERSION=.*/)[0].split('=')[1]
end

def example_state
  settings = cluster_settings
  run_examples = settings['cluster']['guestbook']['run'] || false

  run_examples ? 'start' : 'stop'
end

def final_node_ip 
  settings = cluster_settings
  number_of_nodes = settings['cluster']['nodes'] || 2
  base_ip_address + "#{(number_of_nodes + 2 + 100)}"
end

def get_num_nodes
  settings = cluster_settings
  settings['cluster']['nodes'] || 2
end

def get_coreos_node_info(host_number)
  node_info = Hash.new
  settings = cluster_settings

  case host_number
  when 1
    node_info[:hostname] = 'etcd'
    node_info[:type] = 'etcd'
    node_info[:user_data] = File.join(File.expand_path(File.dirname(__FILE__)), '../cloud_configs/etcd.yaml')
    node_info[:memory] = settings['vmSettings']['etcd']['memory'] || 512 unless settings['vmSettings'].nil?
    node_info[:cpus] = settings['vmSettings']['etcd']['cpus'] || 1 unless settings['vmSettings'].nil?
  when 2
    node_info[:hostname] = 'master'
    node_info[:type] = 'master'
    node_info[:user_data] = File.join(File.expand_path(File.dirname(__FILE__)), '../cloud_configs/master.yaml')
    node_info[:memory] = settings['vmSettings']['master']['memory'] || 512 unless settings['vmSettings'].nil?
    node_info[:cpus] = settings['vmSettings']['master']['cpus'] || 1 unless settings['vmSettings'].nil?
  else      
    node_info[:hostname] = "node-%02d" % (host_number - 2)
    node_info[:type] = 'node'
    node_info[:user_data] = File.join(File.expand_path(File.dirname(__FILE__)), '../cloud_configs/node.yaml')
    node_info[:memory] = settings['vmSettings']['node']['memory'] || 1024 unless settings['vmSettings'].nil?
    node_info[:cpus] = settings['vmSettings']['node']['cpus'] || 1 unless settings['vmSettings'].nil?
  end

  node_info
end

def build_coreos_userdata(host_number)
  node_info = get_coreos_node_info(host_number)
  settings = cluster_settings

  tmp_user_data = "/tmp/#{node_info[:hostname]}-vagrantfile-user-data"
  replacements = {
    '$ETCD_IP' => base_ip_address + "#{1+100}",
    '$MASTER_IP' => base_ip_address + "#{2+100}",
    '$KUBERNETES_VERSION' => 'v' + kubernetes_release,
    '$REBOOT_STRATEGY' => settings['coreos']['rebootStrategy'] || 'off',
    '$CLOUD_PROVIDER' => 'vagrant',
    '$DNS_DOMAIN' => 'kubernetes.local',
    '$SERVICE_PUBLIC_IP' => base_ip_address + "#{3+100}",
    '$RUN_EXAMPLES' => example_state,
    '$DOCKER_CACHE' => base_ip_address + "#{1+100}",
    '$NODE_01_PRIVATE_IP' => base_ip_address + "#{3+100}",
    '$NODE_01_PUBLIC_IP' => ENV['NODE_PUBLIC_IP'] || base_ip_address + "#{3+100}",
    '$FINAL_NODE' => final_node_ip
  }

  regexp = Regexp.new replacements.keys.map {|k| Regexp.quote(k) }.join('|')
  tmp_file = Tempfile.new("tmp_vagrantfile")

  begin
    File.foreach(node_info[:user_data], "r") do |line|
      tmp_file.write line.gsub regexp, replacements
    end
    tmp_file.close
    FileUtils.mv(tmp_file.path, tmp_user_data)
  ensure
    tmp_file.close
    tmp_file.unlink
  end

  tmp_user_data
end

def dot_record_set(record_set)
  # Check record for trailing '.' and add one if missing
  if record_set[-1, 1] == '.'
    record_set_dot = record_set
  else
    record_set_dot = record_set.concat('.')
  end

  record_set_dot
end

def set_kubeconfig(cluster)
  # Output the kubectl config settings at the end of the vagrant run
  # kubectl config set-cluster <cluster> --server=http://<master>:8080 --apiVersion=<api_version>
  # Optional: include instructions on create an alias
  #   Run the following command to create a shortcut on a Mac
  #   alias kub<cluster>="kubectl --cluster=local" 
  settings = cluster_settings

  master = settings['id'] == 'aws' ? aws_master : base_ip_address + "#{2+100}"
  api_version = settings['cluster']['apiVersion']
  puts "\n\033[34mYou can now access the Kubernetes cluster by creating a new cluster in your kubeconfig by running:\033[0m"
  puts "\033[34mkubectl config set-cluster #{cluster} --server=http://#{master}:8080 --api-version=#{api_version}\033[0m"
  puts "\n\033[34mTalk to the kubernetes cluster by running:\033[0m"
  puts "\033[34mkubectl --cluster=#{cluster} [commands]\033[0m\n\n"
end

def run_tests(config, type)
  config.vm.provision :serverspec do |spec|
    spec.pattern = File.expand_path(File.join(File.dirname(__FILE__), '..', 'spec', "*_#{type}_#{ENV['KRAKEN_CLUSTER']}_spec.rb"))
  end
end

install_plugins

begin
  load "#{File.join(File.expand_path(File.dirname(__FILE__)), ENV['KRAKEN_CLUSTER'], 'Vagrantfile')}"
rescue LoadError
  abort "Could not load #{File.join(File.expand_path(File.dirname(__FILE__)), ENV['KRAKEN_CLUSTER'], 'Vagrantfile')}"
end
