# -*- mode: ruby -*-
# vi: set ft=ruby :

# DO NOT EDIT THIS FILE.
# Use the settings.yaml to modify cluster settings.

require 'fileutils'
require 'tempfile'
require 'net/http'
require 'open-uri'
require 'ipaddr'
require 'yaml'
require 'mkmf'
require 'fileutils'

VAGRANTFILE_API_VERSION = "2"
Vagrant.require_version ">= 1.7.2"

# Make the MakeMakefile logger write file output to null.
# Probably requires ruby >= 2.0.0
module MakeMakefile::Logging
  @logfile = File::NULL
end

CLOUDCONFIG_PATH = File.join(__dir__, '..', 'cloud_configs')
SPEC_PATH = File.join(__dir__, '..', 'spec')
CLUSTERS_PATH = ENV.fetch('KRAKEN_CLUSTERS_PATH', File.join(__dir__, 'clusters'))

# fail fast on unspecified or invalid cluster
abort 'KRAKEN_CLUSTER must be defined!' unless ENV.has_key?('KRAKEN_CLUSTER')
CLUSTER_NAME = ENV['KRAKEN_CLUSTER']
CLUSTER_PATH = File.join(CLUSTERS_PATH, CLUSTER_NAME)
abort "#{CLUSTER_NAME} - no such cluster" unless File.directory?(CLUSTER_PATH)

# fail fast if cluster vagrant commands aren't being run through kraken.sh
abort 'VAGRANT_DOTFILE_PATH is not set to the right location.
Make sure to run vagrant commands through kraken.sh' unless ENV['VAGRANT_DOTFILE_PATH'] == CLUSTER_PATH

# all of the externalized settings get loaded here
def cluster_settings
  settings_yaml = File.join(CLUSTER_PATH, 'settings.yaml')
  abort "#{settings_yaml} is not present. Did you create it?" unless File.exist?(settings_yaml)
  YAML.load_file(settings_yaml)
end

def install_plugins
  # for this cluster
  plugins_yaml = File.join(CLUSTER_PATH, 'plugins.yaml')
  install_plugins_from_file(plugins_yaml)

  # plugins required for all clusters
  plugins_yaml = File.join(__dir__, 'plugins.yaml')
  install_plugins_from_file(plugins_yaml)
end

def install_plugins_from_file(plugins_yaml)
  abort "#{plugins_yaml} does not exist" unless File.exist?(plugins_yaml)

  required_plugins = YAML.load_file(plugins_yaml)
  required_plugins['plugins'].each do |plugin|
    need_restart = false
    unless Vagrant.has_plugin? plugin['name'], plugin['version']
      system "vagrant plugin install #{plugin['name']} --plugin-version #{plugin['version']}"
      need_restart = true
    end
    exec "vagrant #{ARGV.join(' ')}" if need_restart
  end
end

def base_ip_address
    settings = cluster_settings
    network = settings['cluster']['network'] || '172.16.1.0/24'

    IPAddr.new(network).to_s.chomp("0")
end

def aws_master
  master = cluster_settings['aws']['masterHostName'] || cluster_settings['aws']['masterPublicIp']
  master
end

def kubernetes_release
  settings = cluster_settings
  version = settings['cluster']['kubernetesVersion'] || 'stable'
  if version == 'stable'
    release_url = "https://storage.googleapis.com/kubernetes-release/release/stable.txt"
    open(release_url).read().gsub('v','').chomp
  else
    version
  end
end

def coreos_channel
  cluster_settings['coreos']['channel'] || 'alpha'
end

def coreos_boxname
  "coreos-#{coreos_channel}"
end

def coreos_url
  "http://#{coreos_channel}.release.core-os.net/amd64-usr/current"
end

def coreos_release
  settings = cluster_settings
  version = settings['coreos']['version'] || 'latest'
  return version unless version == 'latest'

  version_url = "#{coreos_url}/version.txt"
  open(version_url).read().scan(/COREOS_VERSION=.*/)[0].split('=')[1]
end

def example_state
  settings = cluster_settings
  run_examples = settings['cluster']['guestbook']['run'] || false

  run_examples ? 'start' : 'stop'
end

def final_node_ip
  settings = cluster_settings
  number_of_nodes = settings['cluster']['nodes'] || 2
  base_ip_address + "#{(number_of_nodes + 2 + 100)}"
end

def get_num_nodes
  settings = cluster_settings
  settings['cluster']['nodes'] || 2
end

def cluster_services
  services = cluster_settings['cluster'].fetch('services', {})
  services['repo'] ||= 'git://github.com/samsung-ag/kraken-services'
  services['branch'] ||= 'stable'
  services
end

def get_coreos_node_info(host_number)
  node_info = Hash.new
  settings = cluster_settings

  case host_number
  when 1
    node_info[:hostname] = 'etcd'
    node_info[:type] = 'etcd'
    node_info[:user_data] = File.join(CLOUDCONFIG_PATH, 'etcd.yaml')
    node_info[:memory] = settings['vmSettings']['etcd']['memory'] || 512 unless settings['vmSettings'].nil?
    node_info[:cpus] = settings['vmSettings']['etcd']['cpus'] || 1 unless settings['vmSettings'].nil?
  when 2
    node_info[:hostname] = 'master'
    node_info[:type] = 'master'
    node_info[:user_data] = File.join(CLOUDCONFIG_PATH, 'master.yaml')
    node_info[:memory] = settings['vmSettings']['master']['memory'] || 512 unless settings['vmSettings'].nil?
    node_info[:cpus] = settings['vmSettings']['master']['cpus'] || 1 unless settings['vmSettings'].nil?
  else
    node_info[:hostname] = "node-%02d" % (host_number - 2)
    node_info[:type] = 'node'
    node_info[:user_data] = File.join(CLOUDCONFIG_PATH, 'node.yaml')
    node_info[:memory] = settings['vmSettings']['node']['memory'] || 1024 unless settings['vmSettings'].nil?
    node_info[:cpus] = settings['vmSettings']['node']['cpus'] || 1 unless settings['vmSettings'].nil?
  end

  node_info
end

def build_coreos_userdata(host_number)
  node_info = get_coreos_node_info(host_number)
  settings = cluster_settings

  etcd_cluster_ip = base_ip_address + "#{1+100}"
  master_cluster_ip = base_ip_address + "#{2+100}"
  proxy_cluster_ip = base_ip_address + "#{3+100}"
  proxy_public_ip = ENV.fetch('NODE_PUBLIC_IP', proxy_cluster_ip)
  if settings.has_key?('aws')
    proxy_public_ip = settings['aws'].fetch('nodePublicIp', settings['aws'].fetch('proxyHostName', proxy_public_ip))
  end


  tmp_user_data = "/tmp/#{node_info[:hostname]}-vagrantfile-user-data"
  replacements = {
    '$ETCD_IP' => etcd_cluster_ip,
    '$MASTER_IP' => master_cluster_ip,
    '$KUBERNETES_VERSION' => 'v' + kubernetes_release,
    '$KUBERNETES_API_VERSION' => settings['cluster']['apiVersion'],
    '$KUBERNETES_VERBOSITY' => '2',
    '$REBOOT_STRATEGY' => settings['coreos']['rebootStrategy'] || 'off',
    '$CLOUD_PROVIDER' => 'vagrant',
    '$DNS_DOMAIN' => 'kubernetes.local',
    '$SERVICE_PUBLIC_IP' => proxy_cluster_ip,
    '$KRAKEN_SERVICES_BRANCH' => cluster_services['branch'],
    '$KRAKEN_SERVICES_REPO' => cluster_services['repo'],
    # TODO: parse out from cluster.services
    '$KRAKEN_SERVICES_INFLUXDB_GRAFANA_ENABLED' => 'true',
    '$KRAKEN_SERVICES_HEAPSTER_ENABLED' => 'false',
    '$RUN_EXAMPLES' => example_state,
    '$DOCKER_CACHE' => etcd_cluster_ip,
    '$NODE_01_PRIVATE_IP' => proxy_cluster_ip,
    '$NODE_01_PUBLIC_IP' => proxy_public_ip,
    '$FINAL_NODE' => final_node_ip
  }

  regexp = Regexp.new replacements.keys.map {|k| Regexp.quote(k) }.join('|')
  tmp_file = Tempfile.new("tmp_vagrantfile")

  begin
    File.foreach(node_info[:user_data], "r") do |line|
      tmp_file.write line.gsub regexp, replacements
    end
    tmp_file.close
    FileUtils.mv(tmp_file.path, tmp_user_data)
  ensure
    tmp_file.close
    tmp_file.unlink
  end

  tmp_user_data
end

def dot_record_set(record_set)
  # Check record for trailing '.' and add one if missing
  if record_set[-1, 1] == '.'
    record_set_dot = record_set
  else
    record_set_dot = record_set.concat('.')
  end

  record_set_dot
end

def set_kubeconfig(cluster)
  # Output the kubectl config settings at the end of the vagrant run
  # kubectl config set-cluster <cluster> --server=http://<master>:8080 --apiVersion=<api_version>
  # Optional: include instructions on create an alias
  #   Run the following command to create a shortcut on a Mac
  #   alias kub<cluster>="kubectl --cluster=local"
  settings = cluster_settings

  master = settings['id'] == 'aws' ? aws_master : base_ip_address + "#{2+100}"
  api_version = settings['cluster']['apiVersion']
  puts "\n\033[34mYou can now access the Kubernetes cluster by creating a new cluster in your kubeconfig by running:\033[0m"
  puts "\033[34mkubectl config set-cluster #{cluster} --server=http://#{master}:8080 --api-version=#{api_version}\033[0m"
  puts "\n\033[34mTalk to the kubernetes cluster by running:\033[0m"
  puts "\033[34mkubectl --cluster=#{cluster} [commands]\033[0m\n\n"
end

def run_tests(config, type)
  config.vm.provision :serverspec do |spec|
    spec.pattern = File.join(SPEC_PATH, "*_#{type}_#{CLUSTER_NAME}_spec.rb")
  end
end

install_plugins

begin
  cluster_vagrantfile = File.join(CLUSTER_PATH, 'Vagrantfile')
  load cluster_vagrantfile
rescue LoadError
  abort "Could not load #{cluster_vagrantfile}"
end
