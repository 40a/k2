# -*- mode: ruby -*-
# vi: set ft=ruby :

require 'fileutils'
require 'net/http'
require 'open-uri'
require 'ipaddr'
require 'yaml'

# DO NOT EDIT THIS FILE.
# Use the settings.yaml to modify cluster settings.
settings_yaml = File.join(File.dirname(__FILE__), "settings.yaml")
ETCD_YAML = File.join(File.dirname(__FILE__), "../../cloud_configs/etcd.yaml")
MASTER_YAML = File.join(File.dirname(__FILE__), "../../cloud_configs/master.yaml")
NODE_YAML = File.join(File.dirname(__FILE__), "../../cloud_configs/node.yaml")
KUBECONFIG_TMPL = File.join(File.dirname(__FILE__), "../../templates/kubeconfig.tmpl")

if File.exist?(settings_yaml)
  config = YAML.load_file(settings_yaml)
else
  abort("\n\e[1;31;40mERROR: settings.yaml was not found in the local path. Exiting\n\n")
end

vs = config["vmSettings"]
ETCD_MEM = vs["etcd"]["memory"] || 512
ETCD_CPUS = vs["etcd"]["cpus"] || 1
MASTER_MEM =  vs["master"]["memory"] || 512
MASTER_CPUS = vs["master"]["cpus"] || 1
NODE_MEM= vs["node"]["memory"] || 1024 
NODE_CPUS = vs["node"]["cpus"] || 1

cl = config["cluster"]
NETWORK = cl["network"] || '172.16.1.0/24'
RUN_GUESTBOOK= cl["guestbook"]["run"] || false
CLOUD_PROVIDER = 'vagrant'
NUM_NODES = cl["nodes"] || 2
DNS_DOMAIN='kubernetes.local' 
KUBERNETES_VERSION = cl["kubernetesVersion"] || 'stable'
API_VERSION = cl["apiVersion"] || 'v1beta3'

co = config["coreos"]
CHANNEL = co["channel"] || 'alpha'
COREOS_VERSION = co["version"] || 'latest'
REBOOT_STRATEGY = co["rebootStrategy"] || 'off'

# Find the lastest stable release of kubernetes
if KUBERNETES_VERSION == "stable"
  release_url = "https://storage.googleapis.com/kubernetes-release/release/stable.txt"
  kubernetes_release = open(release_url).read().gsub('v','').chomp
  puts "\n" * 2 + ("+" * 61 + "\n") * 2 + "++++" + "\s" * 53 + "++++" + "\n"
  puts "+" * 12 + ">>    Kubernetes Version #{KUBERNETES_VERSION}    <<" + "+" * 12 + "\n"
  puts "++++" + "\s" * 53 + "++++" + "\n" + ("+" * 61 + "\n") * 2 + "\n" * 2
end

BASE_IP_ADDRESS = IPAddr.new(NETWORK).to_s.chomp("0")
ETCD_IP_ADDRESS=BASE_IP_ADDRESS + "#{1+100}"
MASTER_IP_ADDRESS=BASE_IP_ADDRESS + "#{2+100}"
NODE_01_PRIVATE_IP = BASE_IP_ADDRESS + "#{3+100}"
NODE_01_PUBLIC_IP = ENV['NODE_PUBLIC_IP'] || NODE_01_PRIVATE_IP

# Should we run the guestbook example
if RUN_GUESTBOOK
  EXAMPLE_STATE = "start"
else 
  EXAMPLE_STATE = "stop"
end

# Find the final node ip address
FINAL_NODE_IP = BASE_IP_ADDRESS + "#{(NUM_NODES + 2 + 100)}"

# Install all other plugins(gems)
required_plugins = %w(vagrant-triggers)
required_plugins.each do |plugin|
  need_restart = false
  unless Vagrant.has_plugin? plugin
    system "vagrant plugin install #{plugin}"
    need_restart = true
  end
  exec "vagrant #{ARGV.join(' ')}" if need_restart
end

coreos_ami = {
  "ap-northeest-1" => "coreos_production_ami_hvm_ap-northeast-1.txt",
  "ap-southeast-1" => "coreos_production_ami_hvm_ap-southeast-1.txt",
  "ap-southeast-2" => "coreos_production_ami_hvm_ap-southeast-2.txt", 
  "eu-central-1" => "coreos_production_ami_hvm_eu-central-1.txt", 
  "eu-west-1" => "coreos_production_ami_hvm_eu-west-1.txt", 
  "sa-east-1" => "coreos_production_ami_hvm_sa-east-1.txt", 
  "us-east-1" => "coreos_production_ami_hvm_us-east-1.txt", 
  "us-gov-west-1" => "coreos_production_ami_hvm_us-gov-west-1.txt", 
  "us-west-1" => "coreos_production_ami_hvm_us-west-1.txt", 
  "us-west-2" => "coreos_production_ami_hvm_us-west-2.txt" 
}

# Find the latest Coreos version and aws_ami if needed
coreos_url = "http://#{CHANNEL}.release.core-os.net/amd64-usr/#{COREOS_VERSION}"
if COREOS_VERSION == "latest"
  coreos_url = "http://#{CHANNEL}.release.core-os.net/amd64-usr/current"
  version_url = "#{coreos_url}/version.txt"

  @coreos_version = open(version_url).read().scan(/COREOS_VERSION=.*/)[0].split('=')[1]
else
  @coreos_version = COREOS_VERSION
end

SERIAL_LOGGING = (ENV['SERIAL_LOGGING'].to_s.downcase == 'true')
GUI = (ENV['GUI'].to_s.downcase == 'true')

Vagrant.require_version ">= 1.6.0"

(1..(NUM_NODES.to_i + 2)).each do |i|
  case i
  when 1
    hostname = "etcd"
  when 2
    hostname = "master"
  else
    hostname = "node-%02d" % (i - 2)
  end
end

Vagrant.configure(2) do |config|

  # always use Vagrants' insecure key
  config.ssh.insert_key = false
  config.ssh.forward_agent = true

  config.vm.box = "coreos-#{CHANNEL}"
  config.vm.box_version = "= #{@coreos_version}"
  config.vm.box_url = "#{coreos_url}/coreos_production_vagrant.json"

  config.trigger.after [:up, :resume] do
    info "making sure ssh agent has the default vagrant key..."
    system "ssh-add ~/.vagrant.d/insecure_private_key"
  end

  # plugin conflict
  if Vagrant.has_plugin?("vagrant-vbguest") then
    config.vbguest.auto_update = false
  end

  (1..(NUM_NODES.to_i + 2)).each do |i|
    case i
    when 1
      hostname = "etcd"
      user_data = ETCD_YAML
      memory = ETCD_MEM
      cpus = ETCD_CPUS
    when 2
      hostname = "master"
      user_data = MASTER_YAML
      memory = MASTER_MEM
      cpus = MASTER_CPUS
    else      
      hostname = "node-%02d" % (i - 2)
      user_data = NODE_YAML
      memory = NODE_MEM
      cpus = NODE_CPUS
    end

    # Transform yaml files
    tmp_user_data = "/tmp/#{hostname}-vagrantfile-user-data"
    replacements = {
      '$ETCD_IP' => ETCD_IP_ADDRESS,
      '$MASTER_IP' => MASTER_IP_ADDRESS,
      '$KUBERNETES_VERSION' => 'v' + kubernetes_release,
      '$REBOOT_STRATEGY' => REBOOT_STRATEGY,
      '$CLOUD_PROVIDER' => CLOUD_PROVIDER,
      '$DNS_DOMAIN' => DNS_DOMAIN,
      '$SERVICE_PUBLIC_IP' => NODE_01_PRIVATE_IP,
      '$RUN_EXAMPLES' => EXAMPLE_STATE,
      '$DOCKER_CACHE' => ETCD_IP_ADDRESS,
      '$NODE_01_PRIVATE_IP' => NODE_01_PRIVATE_IP,
      '$NODE_01_PUBLIC_IP' => NODE_01_PUBLIC_IP,
      '$FINAL_NODE' => FINAL_NODE_IP
    }
    
    regexp = Regexp.new replacements.keys.map {|k| Regexp.quote(k) }.join('|')
    tmp_file = Tempfile.new("tmp_vagrantfile")
    
    begin
      File.foreach(user_data, "r") do |line|
        tmp_file.write line.gsub regexp, replacements
      end
      tmp_file.close
      FileUtils.mv(tmp_file.path, tmp_user_data)
    ensure
      tmp_file.close
      tmp_file.unlink
    end

    config.vm.define vm_name = hostname do |config2|
      config2.vm.hostname = vm_name

      if SERIAL_LOGGING
        logdir = File.join(File.dirname(__FILE__), "log")
        FileUtils.mkdir_p(logdir)

        serialFile = File.join(logdir, "#{vm_name}-serial.txt")
        FileUtils.touch(serialFile)

        config2.vm.provider :virtualbox do |vb, override|
          vb.customize ["modifyvm", :id, "--uart1", "0x3F8", "4"]
          vb.customize ["modifyvm", :id, "--uartmode1", serialFile]
        end
      end

      config2.vm.network :private_network, ip: BASE_IP_ADDRESS + "#{i+100}"

      if File.exist?(tmp_user_data)
        config2.vm.provision :file, :source => "#{tmp_user_data}", :destination => "/tmp/vagrantfile-user-data"
        config2.vm.provision :shell, :privileged => true, 
        inline: <<-EOF
          mv /tmp/vagrantfile-user-data /var/lib/coreos-vagrant/
        EOF
      end

      # Create .kubeconfig file
      # .kubeconfig will be place in the current path
      kubeconfig_file = File.new(".kubeconfig", "w")
      kubeconfig_tmpl = KUBECONFIG_TMPL
      replacements = {
        '$MASTER_IP' => MASTER_IP_ADDRESS,
        '$API_VERSION' => API_VERSION
      }

      regexp = Regexp.new replacements.keys.map {|k| Regexp.quote(k) }.join('|')

      File.foreach(kubeconfig_tmpl, "r") do |line|
        kubeconfig_file.write line.gsub regexp, replacements
      end

      kubeconfig_file.close
    end
  end
end
